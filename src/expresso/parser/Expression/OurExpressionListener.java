package expresso.parser.Expression;

import java.util.Stack;

import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import expresso.Expression;
import expresso.Number;
import expresso.Product;
import expresso.Sum;
import expresso.Variable;

/**
 * This class implements the ExpressionListener generated by ANTLR
 * and extends ExpressionBaseListener in order to parse arbitrary valid input Expressions.
 */
public class OurExpressionListener extends ExpressionBaseListener{
    
    private Stack<Expression> stack = new Stack<Expression>();
    private Stack<String> operations = new Stack<String>();
    private boolean ignoreLoner = false;
    
    /**
     * {@inheritDoc}
     *
     * <p>Does nothing when entering a line.</p>
     */
    @Override public void enterLine(ExpressionParser.LineContext ctx) { }
    /**
     * {@inheritDoc}
     *
     * <p>Checks to see that the stack is left with a single Expression
     * and that no operations are left when exiting a line.</p>
     */
    @Override public void exitLine(ExpressionParser.LineContext ctx) {
        assert stack.size() == 1;
        assert operations.size() == 0;
    }
    /**
     * {@inheritDoc}
     *
     * <p>Does nothing when entering an Expression.</p>
     */
    @Override public void enterExpression(ExpressionParser.ExpressionContext ctx) {
        if (ctx.getChildCount() == 2 
                && ctx.tail().getChildCount() == 3
                && ctx.tail().getChild(0).getText().equals("+")
                && !operations.isEmpty()
                && operations.peek().equals("*")
                && ctx.getParent().getChildCount() != 4){
            Expression toBeMultiplied = stack.pop();
            stack.push(new Number(1));
            String value = ctx.loner().getChild(0).getText();
            if (value.matches("[a-zA-z]+")){
                Expression variable = new Variable(value);
                stack.push(new Product(toBeMultiplied, variable));
            }else{
                try{
                    int integerVal = Integer.parseInt(value);
                    Expression number = new Number(integerVal);
                    stack.push(new Product(toBeMultiplied, number));
                }catch (NumberFormatException e){
                    double doubleVal = Double.parseDouble(value);
                    Expression number = new Number(doubleVal);
                    stack.push(new Product(toBeMultiplied, number));
                }
            }
            ignoreLoner = true;
        }
    }
    /**
     * {@inheritDoc}
     *
     * <p>When exiting an expression, uses the last operation pushed to combine its 
     * appropriate children, or pushes its left child if nothing is to be combined.</p>
     */
    @Override public void exitExpression(ExpressionParser.ExpressionContext ctx) {
        if (ctx.tail().getChildCount() == 3 && stack.peek().equals(new Number(0))){
            stack.pop();
        }
        Expression rightChild = stack.pop();
        Expression leftChild = stack.pop();
        if (!rightChild.equals(new Number(0))){
            String op = operations.pop();
            if (op.equals("*")){
                Expression product = new Product(leftChild, rightChild);
                stack.push(product);
            }else{
                Expression sum = new Sum(leftChild, rightChild);
                stack.push(sum);
            }
        }else{
            stack.push(leftChild);
        }
    }
    /**
     * {@inheritDoc}
     *
     * <p>When entering a non-empty tail, adds the operation to be performed to ops.</p>
     */
    @Override public void enterTail(ExpressionParser.TailContext ctx) {
        if (ctx.getChildCount() == 3){
            operations.push(ctx.getChild(0).getText());
        }
    }
    /**
     * {@inheritDoc}
     *
     * <p>When exiting an empty tail, adds Number(0) to the stack to represent nothing
     * (will be removed).</p>
     */
    @Override public void exitTail(ExpressionParser.TailContext ctx) {
        if (ctx.getChildCount() == 0){
            stack.push(new Number(0));
        }
    }
    /**
     * {@inheritDoc}
     *
     * <p>Does nothing when entering a loner.</p>
     */
    @Override public void enterLoner(ExpressionParser.LonerContext ctx) { }
    /**
     * {@inheritDoc}
     *
     * <p>Adds either a number or variable to the stack when exiting a loner.</p>
     */
    @Override public void exitLoner(ExpressionParser.LonerContext ctx) {
        if (!ignoreLoner){
            String value = ctx.getChild(0).getText();
            if (value.matches("[a-zA-z]+")){
                Expression variable = new Variable(value);
                stack.push(variable);
            }else{
                try{
                    int integerVal = Integer.parseInt(value);
                    Expression number = new Number(integerVal);
                    stack.push(number);
                }catch (NumberFormatException e){
                    double doubleVal = Double.parseDouble(value);
                    Expression number = new Number(doubleVal);
                    stack.push(number);
                }
            }
        }else{
            ignoreLoner = false;
        }
    }
    
    /**
     * Returns the Expression that this tree walker created after completing its walk along the tree.
     * 
     * @return an Expression representing a client's input String
     */
    public Expression getExpression(){
        return stack.get(0);
    }
}
